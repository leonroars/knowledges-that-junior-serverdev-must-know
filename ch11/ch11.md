# Chapter 11. 자주 쓰는 서버 구조와 설계 패턴

> ***References***
> - *주니어 백엔드 개발자가 반드시 알아야 할 실무 지식, 최범균*
> - [MVC Pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
> - [Models-Views-Controllers](https://mvc.givan.se/papers/Models-Views-Controllers.pdf) by Trygve Reenskaug

---

## I. MVC 패턴 (Model-View-Controller Pattern)
<img width="650" height="433" alt="image" src="https://github.com/user-attachments/assets/216ed14e-176f-44af-90f3-adf14c8dc519" />

- Model, View, Controller 세 가지 요소가 서로 상호작용 하는 구조의 소프트웨어 설계 패턴.
- 원래는 GUIs(Graphic User Interfaces) 설계를 위해 고안된 패턴.
- 하지만 '실제로 정보를 생성, 처리하는 비즈니스 로직' 과 '사용자에게 보여지는 계층'이 서로 분리되어 상호 독립적이라는 부분에서 웹 애플리케이션 설계 부분에서도 각광 받음.
- 각각의 요소는 이론적으로 다음과 같은 역할 및 책임을 수행한다.

> ***Model, View, Controller***
>
> *Model*
> - 회원 가입, 암호 변경 등 비즈니스 영역의 로직 처리.
> - 애플리케이션의 데이터 관리, 로직 수행, 애플리케이션의 비즈니스 규칙 저장 및 관리 책임을 가짐.
>
> *View*
> - 사용자가 보게 될 결과 생성 -> 사용자에게 응답
> - 이론적으로는 '시각적 표현'이기에 API 응답을 반환하는 애플리케이션 서버 프로그램에 대해선 조금 의아할 수 있다.
>   하지만 '사용자에게 전달 혹은 보이는 데이터'라는 점에서 JSON 응답 또한 시각적으로 렌더되는 화면과 다르지 않다는 관점에서 생각해보면 충분히 이해할 수 있다.
>
> *Controller*
> - 사용자의 입력 처리 및 애플리케이션 전반의 흐름 제어를 담당.
> - 사용자로부터 온 요청을 처리하기 위해 필요한 모델을 호출하여 로직을 실행하고, 모델로부터 반환받은 응답(데이터)를 View 계층으로 전달하는 역할을 수행한다.

Smalltalk, Spring MVC, Django 의 설계 사상 혹은 구조로부터 MVC 패턴의 흔적을 살펴보았지만 MVC 패턴이라는 이론을 실제 구현한 방식은 조금씩 차이가 있어 혼란스러운 부분이 있었다.

하지만 디테일한 것을 잠시 밀어두고 MVC 패턴의 핵심을 '흐름 제어, 비즈니스 로직 실행 및 규칙 표현을 담당하는 주체, 사용자 요청에 부합하는 응답을 사용자에게 보여주는(전달하는) 주체' 라는 세 가지 구성요소의 구분으로 생각해보니 이해할 수 있었다.

### Smalltalk-80 : GUIs(Graphic User Interface)를 위한 MVC 패턴
1970년대 후반, Smalltalk 개발자였던 Trygve Reenskaug는 _Xerox PARC(Palo Alto Research Center)_ 의 방문 연구원으로 근무하고 있었다.

이때 그는 사용자가 직접 상호작용 가능한 그래픽 인터페이스를 가진 개인용 컴퓨터를 상상했고 이를 구현하기 위한 패턴을 고심 중이었다.

사용자의 조작에 의해 실행된 명령과 이 처리 결과가 화면에 시시각각 반영되어야 했기 때문에 화면과 데이터 간 결합도를 높이면 재사용성과 유지보수성이 아주 나빠지는 것을 경험한 그는 이 두 가지를 서로 독립적으로 구성하는 패턴을 고안했다.

그렇게 처음엔 model, view, thing, editor 네 가지 요소로 구성되었던 초안이 동료 개발자들과 함께 논의하며 최종적으로 우리가 아는 model, view, controller 세 가지 구성요소를 가진 MVC 패턴으로 정립된 것이다.

Smalltalk-80 의 GUIs 설계에 적용된 MVC 패턴을 살펴보면, 해당 패턴의 각 구성요소는 다음과 같은 역할을 수행한다.

**Model**
- 순수 객체.
- 계산과 상태를 책임지고, 자신의 상태 변화를 View/Controller 쪽에 통지 : *Observer Pattern* 활용.

**View**
- Model을 관찰. -> 직접 변경 X
- 화면 위젯이 Model 이벤트를 받아 다시 그리는 방식으로 작동.

**Controller**
- 마우스·키보드 이벤트를 해석해 Model에 메시지를 전송
- 이때 '마우스 클릭' <-> '버튼 Controller' 와 같이 View-Controller 가 서로 1:1 로 한 쌍, 혹은 일대다 관계의 쌍을 이룸.

**구조적 특성**
- Model->View, View->Controller, Controller->View 와 같이, 화면<->시스템 간 실시간 양방향 소통이 일어나는 구조.

**한계**
- GUIs 가 복잡해지며 점점 필요로 하는 View의 수가 늘어나고, 이에 따라 화면과 쌍을 이루는 Controller 의 수 또한 급증하며 복잡도가 증가.



### Spring MVC 에서의 MVC 패턴 : View 와 Model 간 단방향 소통
HTTP 요청/응답은 프로토콜의 Stateless 특성 상, 연결은 단회성으로 이루어진다.

그렇기 때문에 사용자가 바라보는 화면(View or JSON 응답)과 서버 애플리케이션의 비즈니스 로직 단(Model) 간 실시간 상호 관찰이 불가하다.

Spring MVC 는 MVC 패턴의 철학을 다음과 같이 구현하여 이러한 한계와 더불어 Smalltalk 의 GUIs 설계에서 마주한 문제를 해결하고자 했다.

**Controller 설계**
- *Front Controller(DispatcherServlet)* 를 두어 “모든 요청 진입점 하나”라는 관문을 만듦.
- 이를 통해 GUI MVC에서 수백 Controller를 위젯마다 두던 방식을 라우팅 테이블로 치환한 것과 다름 없음.
- `@Controller` 메서드는 사용자 입력(HTTP 요청)을 해석하고, 필요한 서비스(Model) 호출 후 “어떤 View를 보여줄지”(템플릿 이름, JSON)만 결정.
   실제 비즈니스 규칙은 @Service / 도메인 객체에 둠.

**View**
- View 단계는 정적 HTML 템플릿이거나 HttpMessageConverter가 직렬화한 JSON.
- View가 Model을 관찰하지 않는 대신, 새 요청이 새로운 화면을 전송하는 주기적이고 완전한 새로고침 형태로 이루어짐.

이처럼 Spring MVC 는 MVC 패턴의 각 구성 요소 간 '양방향 흐름' 이 아닌 '단방향 흐름' 구조로 구현되었음을 알 수 있다.

---

## II. 계층형 아키텍처(Layered Architecture)
<img width="497" height="303" alt="image" src="https://github.com/user-attachments/assets/1e16aea5-935a-47c7-8870-22b0623e2443" />

### 1. 정의
- 고유한 역할을 수행하는 계층을 정의하고 이들 간 구분이 명확하도록 설계하는 구조.
- 의존의 방향성을 상위->하위로만 제한하는 것이 일반적.

### 2. 의존 방향에 대한 고찰
계층형 아키텍처의 '단방향 의존으로의 제한'이 어떤 목적으로 고안된 것인지 고민해보았고, 내가 내린 결론은 다음과 같다.

> **각 계층의 상호 독립적 발전 가능성을 포용하기**
> - 프로덕션 환경의 애플리케이션은 시장의 요구에 대응하기 위해 변화한다(보통은 아주 빠르게)
> - 통상, 각 계층의 변화 주기는 다르다. 극단적인 예로, DB Product 의 변경은 잘 일어나지 않지만 서비스에 따라 화면 단의 변화 혹은 탭의 구성과 같은 것들은 자주 발생한다.(ex. 피파 온라인의 이벤트는 자주 바뀌고 이벤트를 모아둔 웹페이지도 따라서 자주 변화해야한다.)
> - 즉, 애플리케이션 또는 서비스의 확장이 용이하도록 하기 위함인 것이다.

> **인간이 고칠 수 있는 수준에 잡아두기**
> - 의존의 방향을 제약함으로써, 특정 계층의 변경으로 인한 파급효과의 전파 범위가 통제 가능한 수준에 머무르도록 할 수 있다.
> - 이를 통해 유지 보수가 매우 용이하진 않더라도 마음 먹으면 가능한 수준에 머무르도록 할 수 있다.

### 3. 웹 애플리케이션에서의 계층형 아키텍처 : 4계층 구조
<img width="653" height="258" alt="image" src="https://github.com/user-attachments/assets/346d489e-911b-4cb5-9b17-e9a01e130d0b" />

**표현 계층(Presentation Layer)**
- 사용자와의 상호 작용으 ㄹ담당
- 사용자의 요청 처리를 응용 계층에 위임.
- MVC 패턴의 Controller, View 가 이 계층에 해당.

**응용 계층(Application Layer)**
- 사용자의 요청을 실제로 처리.
- 도메인 모델이 비즈니스 로직 책임을 가짐에도 왜 응용 계층이 필요한가? 응용 계층의 관심사는 'Cross-domain' 으로 이해할 수 있다. Facade 클래스를 대표적인 응용 계층의 예시로 들 수 있다.
- 모델 계층 혹은 인프라 계층을 사용해서 필요한 기능을 구현하고 결과를 표현 계층에 반환.

**도메인/모델 계층**
- 주문 모델의 취소 제약 조건과 같은 해당 도메인의 '비즈니스 규칙', 예약 취소에 따라 예약 상태를 취소로 바꾸는 '상태 변경' 같은 로직을 처리하는 도메인 모델이 위치한 계층.
- 도메인 모델 계층을 만들지 않는 경우도 있지만, 그럴 경우 도메인 규칙 혹은 도메인 로직 실행 책임을 오롯히 지는 주체가 없어져 '로직이 여러 계층에 걸쳐 흩어지는 현상'이 발생할 수 있다.
```java
public class UserPointBalance {
    private String id;
    private String userId;
    private Point balance;

    /**
     * @param userId
     * @param balance
     */
    private UserPointBalance(
            String id,
            String userId,
            Point balance
    ) {
        this.id = id;
        this.userId = userId;
        this.balance = balance;
    }

...

    /**
     * 비즈니스 정책을 위반하지 않는 경우, 사용자의 포인트 잔액을 증가시킵니다.
     *
     * @param increaseAmount 더해질 포인트 양. 해당 양은 0 이상이어야 하며, 이를 기존 잔액과 더했을 때 총합은 1,000,000점 이하여야 한다.
     * @return (기존 보유량 + 인자로 주어진 추가량) 을 잔액으로 갖는 새로운 {@code UserPointBalance} 객체 인스턴스를 생성하여 반환한다.
     * @throws BusinessRuleViolationException 충전하고자 하는 양이 0 미만이거나 기존 잔액과 합이 1,000,000 점 초과하는 경우
     */
    public UserPointBalance increase(int increaseAmount) {
        // Fail : 0보다 작은 충전 금액 충전 시도
        if (increaseAmount < 0) {
            throw new BusinessRuleViolationException("충전하고자 하는 포인트는 0보다 커야 합니다.");
        }
        int newAmount = this.balance().getAmount() + increaseAmount;
        // Success : 합산된 잔액을 갖는 새로운 UserPointBalance 객체 인스턴스 생성 후 반환.
        this.balance = Point.create(newAmount);
        return this;
    }

```

**인프라/영속 계층**
- DB 연동 혹은 문자 발송과 같은 구현 기술을 지원.
- 애플리케이션 외부의 인프라와의 소통을 담당하는 부분이 해당 계층에 위치한다.

---

## III. DDD(Domain Driven Design)와 전략 패턴

### 1. DDD(Domain Driven Design)
- Eric Evans 의 저서인 _Domain-Driven Design: Tackling Complexity in the Heart of Software_ 를 통해 소개된 설계 철학
- 비즈니스가 다루는 '문제 영역'을 일컫는 도메인을 서비스 또는 애플리케이션 설계의 핵심으로 바라보는 것을 말함.
- 이러한 도메인 중심 사고는 전반적인 개발 프로세스에서 찾아볼 수 있지만(ex. 도메인 전문가와 함께 팀원이 공유하는 도메인 용어집 - _Ubiquotos Language_ - 를 설계 단계에서 만드는 것 등),
  소프트웨어 개발 과정에서 구체적으로 이러한 철학을 반영하는 사례로, 상기한 4 계층의 애플리케이션 아키텍처에서 **다른 계층이 도메인 계층을 의존하도록 하고 도메인 계층은 다른 어떤 계층에도 의존하지 않도록 설계** 하는 방식으로 반영하기도 한다.

### 2. DDD : 도메인 모델의 구성 요소

**엔티티(Entity)**
> *"...Slightly rephrased: Does the user of the application care if I am the
same person I was at age 5?"*
> 
> From *Domain-Driven Design: Tackling Complexity in the Heart of Software*, Eric Evans

- 속성과 속성값이 아닌 '고유 식별자(ID)'를 통해 식별되는 객체.
- ex. 주문 엔티티 : 주문 고유번호를 통해 상호 구분됨.

**밸류(Value 혹은 Value Object)**
- 고유 식별자가 아닌 가진 속성과 그 속성 값에 의해 구분되는 객체.
- ex. 배송 주소 등

**애거리거트(Aggregate)**
- 관련 객체를 묶어 하나의 개념적인 단위를 표현하는 객체.
- 어떤 도메인 모델의 단일 진입점으로 생각해볼 수 있다.
- ex. Order 엔티티, OrderLine VO, ShippingAddress VO 로 구성되는 주문 Aggregate 객체.
- 해당 개념 단위가 포함하는 관련 객체들의 상태 변경이 애거리거트를 통해 이루어지도록 함으로써(즉, 단일진입점으로 활용), 관련 모델들의 상태 관리가 보다 일관성있게 이루어질 수 있도록 할 수 있음.

**리포지토리(Repository)**
- 도메인 객체를 물리적인 저장소와 연결할 때 사용하는 모델.
- 도메인 객체 저장 및 조회 시 사용되는 인터페이스 제공.
- 통상, 애거리거트 단위로 존재.

```java
@Entity
@Getter
@Table(name = "POINTBALANCE")
public class UserPointBalanceJpaEntity extends BaseJpaEntity{

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "point_balance_id")
    private Long id;
    private String userId;
    private int point;

    @Version
    private Long version; // 낙관적 락 적용을 위한 Version 필드.

    // UserPointModel(Domain Model) -> UserPointBalanceJpaEntity(JPA entity model)
    public static UserPointBalanceJpaEntity fromDomain(UserPointBalance domainModel) {
        UserPointBalanceJpaEntity entity = new UserPointBalanceJpaEntity();
        if(domainModel.id() != null && !domainModel.id().isBlank()){
            entity.id = Long.valueOf(domainModel.id());
        }
        entity.userId = domainModel.userId();
        entity.point = domainModel.balance().getAmount();
        return entity;
    }


    // UserPointBalanceJpaEntity(JPA entity model) -> UserPointModel(Domain Model)
    public UserPointBalance toDomain() {
        return UserPointBalance.create(String.valueOf(this.id), this.userId, Point.create(this.point));
    }

    // UserPointBalanceJpaEntity 내에 updateFromDomain 구현 예시
    public UserPointBalanceJpaEntity updateFromDomain(UserPointBalance domain) {
        // this.id, this.version 은 그대로 유지
        this.userId = domain.userId();
        this.point = domain.balance().getAmount();
        return this;
    }
}
```

**도메인 서비스**
- 특정한 애거리거트에 속하지 않은 로직을 구현.
- ex. DB와 같은 외부 연동이 필요한 도메인 로직 등.

**도메인 이벤트**
- 도메인 내에서 발생한 이벤트를 표현.
- 도메인의 상태가 변경될 대 도메인 이벤트를 발생 시킴.
- 해당 도메인의 변화를 알리기 위해 고안된 객체.
```java
public record PaymentEvent(
        String userId,
        Integer point,
        String reservationId
) {
    public static PaymentEvent fromDomain(String userId, Integer point, String reservationId){
        return new PaymentEvent(
                userId,
                point,
                reservationId
        );
    }
}
```
**바운디드 컨텍스트(Bounded Context)**
- 도메인의 경계를 의미.
- 통상, 도메인 전문가와 팀이 정의한 공용어(Ubiquotos Language) 를 사용하는 구성원의 범위에 의해 정의된다.
- ex. 어떤 팀에서는 '충전'이 고객의 간편 결제를 위한 '포인트 충전'을 의미할 수 있지만, 다른 부서에서는 사용자의 전기차 차량 충전을 의미할 수 있음. 즉, '충전'이라는 용어가 같은 의미로 이해될 수 있는 범위가 하나의 바운디드 컨텍스트.

---

## IV. 마이크로서비스 아키텍처

**정의**
- 개념적, 물리적으로 상호 독립적인 서비스 간 느슨한 결합에 근거하여 설계된 서비스 아키텍처.
- 비용을 지불하여 구조적 안정성 획득을 목표로 하는 아키텍처
- 각각의 마이크로서비스, 혹은 마이크로서비스 아키텍처를 여러 가지 관점에서 정의할 수 있지만, 보편적으로 받아들여지는 것은 크게 다음의 조건을 만족하는지 여부이다.
  - 독립적 배포
  - 도메인 중심 모델링
  - 자신의 상태를 가짐 : DBPS(Database Per Service) 를 의미함.
  - 아키텍처와 조직의 구조적 유사성 : 콘웨이의 법칙에 의하면 어떤 시스템의 구조는 해당 시스템을 설계하는 조직의 소통 구조를 닮는다.

**모놀리식 v.s MSA**

| 구분   | 모놀리식 | 마이크로서비스 |
|--------|-----------|----------------|
| **장점** | • 배포가 단순하다.<br>• 코드 관리가 더 쉽다.<br>• 성능을 높이기 위해 복잡한 구조를 가질 필요가 없다.<br>• 테스트와 디버깅이 쉽다. | • 독립적인 배포와 지속적인 배포가 용이하다.<br>• 성능 확장이 용이하다.<br>• 기술에 대한 유연성을 가질 수 있다.<br>• (보통) 개발자의 만족도가 더 높다. |
| **단점** | • 규모가 커질수록 개발 속도가 느려질 수 있다.<br>• 한 기능의 문제가 전체에 영향을 줄 수 있다.<br>• 구현 기술 변경에 어려움이 있다.<br>• 작은 변경도 전체를 다시 배포해야 한다. | • 테스트와 디버깅이 어려울 수 있다.<br>• 모놀리식 대비 인프라가 복잡해진다.<br>• 소통에 따른 부하가 증가할 수 있다.<br>• 무분별하게 서비스를 만들면 분산 모놀리식이 될 수 있다. |

---
## V. 이벤트 기반 아키텍처

### 1. 정의
- 두 시스템 간 통신에 이벤트를 사용하는 구조.
- 이벤트는 '이미 발생한 사실을 표현하는 데이터'으로, 그렇기 때문에 주로 과거형으로 표현한다.

### 2. 이벤트 기반 아키텍처 : 구성 요소
**이벤트 생산자**
- 이벤트를 발행하는 주체.
- Publisher, Producer 와 같은 이름으로 표현된다.

**이벤트 소비자**
- 발행된 이벤트에 따라 어떤 작업을 실행하는 주체.
- Subscriber, Consumer 와 같은 이름으로 표현된다.

**이벤트 브로커(이벤트 라우터)**
- 발행된 이벤트를 소비자에게 전달하는 주체.
- 애플리케이션 밖에 존재하는 어떤 인프라스트럭처를 이벤트 브로커로 활용하는 경우, 이벤트의 전달 상태 추적을 위해 추가적인 수단이 필요할 수 있다. (ex. DB 를 활용한 Outbox Pattern)
- 이벤트를 전달이 아니라 '저장'할 수도 있는 브로커라면, 해당 기능을 활용하여 이를 '단일 진실 공급원(Single Source of Truth)' 로 확장하여 활용할 수 있다.

---

## Chapter VI. CQRS 패턴
<img width="637" height="464" alt="image" src="https://github.com/user-attachments/assets/0bce5e49-684d-4741-a754-d1cf493b6eb8" />


### 1. 정의
- 조회와 변경 책임을 분리하여, 각각을 위한 개별적인 모델을 만들어 분리하는 패턴.

### 2. 왜 필요한가?
- 단순한 시스템이라면 하나의 도메인 모델이 가진 여러 필드 중 필요에 따라 선택하는 방식으로 조회와 변경에 모두 '단일 모델'을 활용할 수 있음.
- 하지만 복잡한 시스템이라면 필연적으로 도메인 모델의 크기(ex. 속성의 수) 가 커지는 경우가 빈번.
- 또한 복잡한 시스템일수록 조회와 변경(읽기와 쓰기로 표현하기도 한다.) 작업에 필요한 데이터의 종류가 다른 경우도 많음.
- 이때 하나의 단일 모델을 활용하면 추가 되는 기능을 지원하기 위해 점점 커지게 되고 유지보수성을 저해하게 됨.

### 3. 장점
- 각 기능에 맞게 모델을 구현할 수 있음 -> 상호 간 변경으로 인한 영향 차단 가능.
- 조회 모델이 별도로 존재 -> 조회 성능 향상이 용이함(ex. 조회 모델 Caching, 조회 전용 DB 확장 등)

### 4. 단점
- 기능 별 모델 존재 -> 유지 보수 포인트 증가
- 따라서 도입에 따른 Trade-off 잘 고려해야함.
- 구현 기술이 늘어날 수 있다.
  - 명령 모델과 조회 모델을 서로 다른 기술로 구현하는 경우도 많음. (ex. 높은 조회 성능을 위해 조회 모델을 위한 별도 조회 전용 DB 구축 등)
  - 그럴 경우, 쓰기 DB <-> 읽기 DB 간 동기화 전략이 필요.
- 이
