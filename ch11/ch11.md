# Chapter 11. 자주 쓰는 서버 구조와 설계 패턴

> ***References***
> - *주니어 백엔드 개발자가 반드시 알아야 할 실무 지식, 최범균*
> - [MVC Pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
> - [Models-Views-Controllers](https://mvc.givan.se/papers/Models-Views-Controllers.pdf) by Trygve Reenskaug

---

## I. MVC 패턴 (Model-View-Controller Pattern)
<img width="650" height="433" alt="image" src="https://github.com/user-attachments/assets/216ed14e-176f-44af-90f3-adf14c8dc519" />

- Model, View, Controller 세 가지 요소가 서로 상호작용 하는 구조의 소프트웨어 설계 패턴.
- 원래는 GUIs(Graphic User Interfaces) 설계를 위해 고안된 패턴.
- 하지만 '실제로 정보를 생성, 처리하는 비즈니스 로직' 과 '사용자에게 보여지는 계층'이 서로 분리되어 상호 독립적이라는 부분에서 웹 애플리케이션 설계 부분에서도 각광 받음.
- 각각의 요소는 이론적으로 다음과 같은 역할 및 책임을 수행한다.

> ***Model, View, Controller***
>
> *Model*
> - 회원 가입, 암호 변경 등 비즈니스 영역의 로직 처리.
> - 애플리케이션의 데이터 관리, 로직 수행, 애플리케이션의 비즈니스 규칙 저장 및 관리 책임을 가짐.
>
> *View*
> - 사용자가 보게 될 결과 생성 -> 사용자에게 응답
> - 이론적으로는 '시각적 표현'이기에 API 응답을 반환하는 애플리케이션 서버 프로그램에 대해선 조금 의아할 수 있다.
>   하지만 '사용자에게 전달 혹은 보이는 데이터'라는 점에서 JSON 응답 또한 시각적으로 렌더되는 화면과 다르지 않다는 관점에서 생각해보면 충분히 이해할 수 있다.
>
> *Controller*
> - 사용자의 입력 처리 및 애플리케이션 전반의 흐름 제어를 담당.
> - 사용자로부터 온 요청을 처리하기 위해 필요한 모델을 호출하여 로직을 실행하고, 모델로부터 반환받은 응답(데이터)를 View 계층으로 전달하는 역할을 수행한다.

Smalltalk, Spring MVC, Django 의 설계 사상 혹은 구조로부터 MVC 패턴의 흔적을 살펴보았지만 MVC 패턴이라는 이론을 실제 구현한 방식은 조금씩 차이가 있어 혼란스러운 부분이 있었다.

하지만 디테일한 것을 잠시 밀어두고 MVC 패턴의 핵심을 '흐름 제어, 비즈니스 로직 실행 및 규칙 표현을 담당하는 주체, 사용자 요청에 부합하는 응답을 사용자에게 보여주는(전달하는) 주체' 라는 세 가지 구성요소의 구분으로 생각해보니 이해할 수 있었다.

### Smalltalk-80 : GUIs(Graphic User Interface)를 위한 MVC 패턴
1970년대 후반, Smalltalk 개발자였던 Trygve Reenskaug는 _Xerox PARC(Palo Alto Research Center)_ 의 방문 연구원으로 근무하고 있었다.

이때 그는 사용자가 직접 상호작용 가능한 그래픽 인터페이스를 가진 개인용 컴퓨터를 상상했고 이를 구현하기 위한 패턴을 고심 중이었다.

사용자의 조작에 의해 실행된 명령과 이 처리 결과가 화면에 시시각각 반영되어야 했기 때문에 화면과 데이터 간 결합도를 높이면 재사용성과 유지보수성이 아주 나빠지는 것을 경험한 그는 이 두 가지를 서로 독립적으로 구성하는 패턴을 고안했다.

그렇게 처음엔 model, view, thing, editor 네 가지 요소로 구성되었던 초안이 동료 개발자들과 함께 논의하며 최종적으로 우리가 아는 model, view, controller 세 가지 구성요소를 가진 MVC 패턴으로 정립된 것이다.

Smalltalk-80 의 GUIs 설계에 적용된 MVC 패턴을 살펴보면, 해당 패턴의 각 구성요소는 다음과 같은 역할을 수행한다.

**Model**
- 순수 객체.
- 계산과 상태를 책임지고, 자신의 상태 변화를 View/Controller 쪽에 통지 : *Observer Pattern* 활용.

**View**
- Model을 관찰. -> 직접 변경 X
- 화면 위젯이 Model 이벤트를 받아 다시 그리는 방식으로 작동.

**Controller**
- 마우스·키보드 이벤트를 해석해 Model에 메시지를 전송
- 이때 '마우스 클릭' <-> '버튼 Controller' 와 같이 View-Controller 가 서로 1:1 로 한 쌍, 혹은 일대다 관계의 쌍을 이룸.

**구조적 특성**
- Model->View, View->Controller, Controller->View 와 같이, 화면<->시스템 간 실시간 양방향 소통이 일어나는 구조.

**한계**
- GUIs 가 복잡해지며 점점 필요로 하는 View의 수가 늘어나고, 이에 따라 화면과 쌍을 이루는 Controller 의 수 또한 급증하며 복잡도가 증가.



### Spring MVC 에서의 MVC 패턴 : View 와 Model 간 단방향 소통
HTTP 요청/응답은 프로토콜의 Stateless 특성 상, 연결은 단회성으로 이루어진다.

그렇기 때문에 사용자가 바라보는 화면(View or JSON 응답)과 서버 애플리케이션의 비즈니스 로직 단(Model) 간 실시간 상호 관찰이 불가하다.

Spring MVC 는 MVC 패턴의 철학을 다음과 같이 구현하여 이러한 한계와 더불어 Smalltalk 의 GUIs 설계에서 마주한 문제를 해결하고자 했다.

**Controller 설계**
- *Front Controller(DispatcherServlet)* 를 두어 “모든 요청 진입점 하나”라는 관문을 만듦.
- 이를 통해 GUI MVC에서 수백 Controller를 위젯마다 두던 방식을 라우팅 테이블로 치환한 것과 다름 없음.
- `@Controller` 메서드는 사용자 입력(HTTP 요청)을 해석하고, 필요한 서비스(Model) 호출 후 “어떤 View를 보여줄지”(템플릿 이름, JSON)만 결정.
   실제 비즈니스 규칙은 @Service / 도메인 객체에 둠.

**View**
- View 단계는 정적 HTML 템플릿이거나 HttpMessageConverter가 직렬화한 JSON.
- View가 Model을 관찰하지 않는 대신, 새 요청이 새로운 화면을 전송하는 주기적이고 완전한 새로고침 형태로 이루어짐.

이처럼 Spring MVC 는 MVC 패턴의 각 구성 요소 간 '양방향 흐름' 이 아닌 '단방향 흐름' 구조로 구현되었음을 알 수 있다.

---


