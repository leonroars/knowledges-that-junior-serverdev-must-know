# 9장. 최소한 알고있어야 할 서버 지식

> ***Introduction***
> - 규모가 큰 회사는 인프라 및 플랫폼 담당 팀과 서비스 개발팀이 분리되어 있음.
> > - 때문에 규모가 큰 회사에서 백엔드 개발 시작 시 OS 설치 및 설정, 관리 경험을 하지 못하기도 함.
> - 그러나, 서버 OS 에 대한 경험이 없다면, 문제 발생 시 해당 문제가 애플리케이션 레벨인지 OS 레벨인지 확인하기 어려울 수 있음.
> - 따라서, 기본적인 서버 관리는 할 수 있어야 한다.

> *서버 V.S 서버 프로그램*
> - *서버* 라는 용어는 맥락에 따라 다양한 대상을 의미함.
> > - ex. 물리 장비 혹은 가상화 장비, OS, 아파치 및 톰캣과 같은 웹 서버를 지칭할 때 모두 *서버* 라는 용어를 사용하기도 한다.
> - 본 챕터에서는 혼동을 피하기 위해 <u>서버 프로그램을 구동하는 OS를 *서버* </u>, 아파치 또는 톰캣 같은 프로그램은 *서버 프로그램* 으로 지칭하기로 정한다.
> - 또한, OS는 Linux 를 전제로 설명한다. 가장 많이 사용되는 OS 이기 때문.


## I. OS 계정과 권한

### 1. Linux OS 계정 종류
- 크게 다음의 두 가지 계정 종류가 존재한다.
  - *root*
  - *사용자(User)*
- Linux 에는 복수의 사용자를 묶어 지정하는 '그룹'의 개념도 존재한다.

> **root**
> - OS 설치 시 기본 생성되는 계정.
> - 모든 권한 보유한 *관리자 계정*
> - 통상 인프라 담당자만 해당 계정 접근 권한 보유 / 나머지 개발자는 별도로 생성한 사용자 계정 활용하여 서버 연결.
   

### 2. 파일/디렉토리에 대한 권한 확인 및 수정

#### 권한 확인
어떤 파일 혹은 디렉토리 실행 및 접근이 거부될 경우, 대상의 읽기/실행 권한을 확인해볼 필요가 있다.
리눅스에서는 `ls` 명령어를 활용하여 설정된 권한을 확인할 수 있다.
다음은 `ls -l` 명령어를 실행한 결과이다.

```console
-rw-r--r--. 1 vagrant vagrant 7 11월 10 08:24 README.md
-rwxr--r--. 1 vagrant vagrant 7 11월 10 08:26 run.sh
```
가장 앞의 9자리가 권한을 표현하는 정보이다.
다음과 같이 해석한다.
- 첫 세 자리 : 파일 및 디렉토리 소유자의 권한.
- 중간 세 자리 : 그룹의 권한.
- 마지막 세 자리 : 소유자 외 다른 계정의 권한

이에 따라 `README.sh` 접근 및 실행 권한을 해석해보면 다음과 같다.
- 소유자 : 읽기 및 쓰기 가능(`-rw`)
- 그룹 : 읽기만 가능(`r--`)
- 다른 계정 : 읽기만 가능(`r--`)

읽기(`w`)/쓰기(`r`)/실행(`x`) 는 다음과 같이 숫자와 대응하여 표현하기도 한다.
- `r` -> 4
- `w` -> 2
- `x` -> 1

#### 권한 수정
권한의 수정은 `chmod` 명령어를 활용한다. `chmod` 는 *Change Mode* 를 줄인 표현이다.
이를 활용하여 어떤 파일/디렉토리의 접근/실행 권한을 변경할 때에는 크게 두 가지 방법이 있다.
> 1) r, w, x 에 대응하는 숫자의 합을 활용하는 방법.
> 2) 대상과 권한, 그리고 명령어를 표현하는 영소문자를 활용하는 방법.
> 3) `sudo` 명령어를 활용하여 다른 사용자의 권한 획득하기.

> **1) r, w, x 에 대응하는 숫자의 합을 활용하는 방법**

예를 들어 `run.sh` 의 권한을 다음과 같이 변경하였다고 가정해보자.
```console
$ chmod 754 run.sh
```
`754` 는 각각 소유자, 그룹, 소유자 외 계정의 실행 및 접근 권한을 숫자 합으로 표현한 것이다.
즉, 다음과 동일하다.

```console
-rwxr-xr--. 1 vagrant vagrant 7 11월 10 08:26 run.sh
```
> **2) 대상과 권한, 그리고 명령어를 표현하는 영소문자를 활용하는 방법**
파일/디렉토리의 권한 설정 변경을 다음과 같은 관점에서 바라볼 수 있다.
1) 사용자 : '누구의 권한인가?' 를 의미한다. 소유자는 `u`, 그룹은 `g`, 다른 사용자는 `o`, 모든 사용자는 `a` 로 표현한다.
2) 동작 : 대상 사용자의 어떤 권한을 새로 부여할 것인지, 제거할 것인지와 같은 행위를 의미한다. 추가는 `+`, 제거는 `-`, 지정은 `=` 으로 표현한다.
3) 권한 : 어떤 권한을 추가 또는 제거할 것인지를 말한다. 각 권한은 앞서 기술한 바와 동일하다.

이를 활용하여 다음과 같이 `chmod` 명령어를 사용할 수 있다.
```console
$ chmod u+x run.sh
```
'소유자에게 run.sh 파일의 실행 권한을 부여하도록 설정한다.' 는 의미와 동일하다.

> **3) `sudo` 명령어를 활용하여 다른 사용자의 권한 획득하기

> **`sudo`**
- 현재 사용자로 실행 및 접근할 수 없는 파일/디렉토리에 접근하기 위해, 타당한 권한이 있는 사용자의 권한을 사용하여 실행하도록 하는 명령어

#### 왜 필요할까?
다음과 같은 상황을 생각해볼 수 있다.

- 서버의 root 권한을 일부 인프라 담당자만 갖는 경우가 많다.
- 개발자는 일반 계정을 부여받는다.
- 하지만 개발자도 root 권한이 필요한 상황이 왕왕 있다. (ex. `systemctl` 명령어로 아파치 서비스를 재시작해야 하는 경우 등)
- 그럴 때마다 인프라 담당자에게 전화를 해야 한다면 모두가 슬퍼진다.
- 그러나 root 계정을 냅다 넘겨주기엔 보안 관련하여 우려가 되는 지점이 있다.

이러한 상황을 타개하기 위해선 다음과 같은 것이 필요하다.
- 일반 사용자도 root 권한으로 접근/실행 가능한 파일 및 디렉토리에 접근해야 할 때가 있다.
- 하지만 root 계정 소유주의 입장에선, 모든 파일 및 디렉토리에 그런 방식으로 접근하도록 허용하기엔 무리가 있다.
- 따라서, root 계정 소유주가 '허용하는 범위'에 대해선 가능하도록 하는 방안이 있다.

위의 세 가지를 모두 제공하는 것이 바로 `sudo` 명령어 이다.

#### `sudo` 명령어를 사용하기 위한 설정 및 사용

- `sudo` 명령어의 제약조건을 정의하는 파일이 바로 `/etc/sudoers` 혹은 `/etc/sudoers.d/` 디렉토리에 위치한 파일.

해당 파일 내부에는 다음과 같은 사항이 기록되어 있다.
```console
root    ALL=(ALL) ALL
```

그리고 다음과 같이 해석할 수 있다.

- `root` : root 계정은,
- `ALL` : 모든 호스트에 대해
- `(ALL)` : 모든 사용자로 실행할 수 있다. ('as' 로 이해하면 알기 쉽다.)
- `ALL` : 모든 명령어를 실행할 수 있다.(허용 범위 정의)

하지만 '부여 받은 계정' 에 암호가 설정되어 있는 경우, 다음과 같은 설정으로 암호 입력을 우회할 수 있다.

```console
user1    ALL=(ALL) ALL NOPASSWD: ALL
```

위의 설정은 `user1`이 `sudo` 명령어를 사용할 경우, 어떤 파일/디렉토리에 접근 및 실행하더라도 암호를 요구하지 않도록 하는 것이다.
하지만 이는 다시 보안 취약점을 드러낼 가능성이 있다.

따라서 명확하게 필요한 부분을 정의하여, 해당 부분에 대해서만 `sudo` 명령어 사용이 가능하도록 하는 것이 좋다.

```console
user1    ALL=(ALL) NOPASSWD: /usr/bin/systemctl start docker
```

## II. 프로세스 확인하기
서버 내 실행되고 있는 프로세스를 확인하고 필요 시 종료 및 강제 종료 하는 방법 숙지가 필요하다.
다음과 같은 시나리오가 현업에서 드물지 않게 발생하기 때문.
- 서버 프로그램 재시작 시도 시 기존 프로세스 미종료로 인한 실패
- 서버 프로그램 시작 과정에서 문제가 발생 해 프로세스 구동에 실패하는 상황

#### 프로세스 상태 확인
두 가지 명령어가 많이 사용된다.
- **`ps aux`**
- **`ps -eaf`**

두 가지 명령어 모두 다음의 정보를 출력한다.
- 1) 실행 중인 프로세스 소유자
  2) 실행 중인 프로세스ID
  3) 해당 프로세스 실행 시의 command-line arugment

#### 프로세스가 사용 중인 리소스 상태 실시간 확인
크게 두 가지 프로그램이 활용된다.
- **`top`**
- **`htop`**

`ps` 명령어로도 리소스 모니터링이 가능하다.

```console
$ ps aux --sort -rss | head -n 6
```
위의 명령어는 프로세스가 점유하는 메모리 사용량이 높은 순서로 상위 5개를 출력한다.

#### 프로세스 종료
프로세스 종료 시엔 기본적으로 `kill` 명령어를 사용한다.

```console
$ kill 옵션 PID
```

해당 명령어 사용 시엔 크게 다음의 두 가지 실행 옵션을 활용한다.
> `-15` 또는 `-s SIGTERM`, 혹은 `-TERM`
>  - 대상 프로세스에 *TERM(TERMINATE)* 신호를 보낸다.
>  - 따라서 신호를 받은 프로세스는 종료에 필요한 작업을 수행 후 종료한다.(ex. 스프링 빈 제거 처리, 임시 생성 파일 삭제 등)

> `-9` 또는 `-s SIGKILL`, 또는 `-KILL`
>  - 강제 종료.
>  - 시그널을 보내지 않아 종료에 필요한 작업이 수행되지 않으므로, 해당 프로세스가 점유한 자원의 정상적인 반납이 이루어지지 않을 수 있다.


## III. 백그라운드 프로세스

#### 0. 터미널을 이해해보기.
- Terminal 이라는 영어 단어의 의미를 생각해보면 터미널의 역할을 이해하기 용이하다.
- 메인프레임 컴퓨터를 사용하던 시절, 해당 컴퓨터와 사용자가 상호작용할 수 있는 '창구' 가 필요했음.
- 터미널은 바로 이 창구 역할을 수행했다.
- 당시의 터미널은 스크린과 키보드와 같은 입력/출력 장치만 연결된 장치였다.

### 1. 포그라운드 프로세스 (Foreground Process)
- 터미널과 연결된 프로세스로, 키보드 혹은 스크린을 통해 사용자와 상호작용함.
- 사용자와 터미널의 연결이 끊기면 종료된다. 가령, 네트워크 이상으로 서버와의 연결이 끊기면 실행 중이던 `tail` 혹은 `vi` 프로세스는 종료된다.
- ex. `tail`, `top`, `vi`

### 2. 백그라운드 프로세스(Background Process)
- 터미널과 연결되지 않은 프로세스.
- 그렇기에 키보드 혹은 스크린을 통해 사용자와 상호작용 불가.

> **왜 백그라운드 프로세스가 필요한가?**
> - 사용자의 관심과 직접적으로 연관되지 않거나, 사용자로부터 방해 받지 않을 필요가 있는 프로세스가 있기 때문.
> - ex. OS의 로깅, 모니터링, 스케쥴링 등.

- Linux 에서는 명령어 뒤에 `&` 를 붙임으로서 해당 프로세스를 백그라운드로 실행 가능.
```console
$ java -Dserver.port=9090 -jar server.jar &
```

- 사용자가 로그아웃하더라도 해당 백그라운드 프로세스가 유지되어야 한다면 `nohup` 명령어를 `&`과 함께 사용하면 된다.
```console
$ nohup java -Dserver.port=9090 -jar server.jar &
[1] 12345
$ nohup: ignoring input and appending output to 'nohup.out'
```

> **`nohup`**
> - *No Hang Up* 을 뜻하는 명령어.
> - 사용자-터미널 간 연결이 종료될 때 전송되는 `HUP` 시그널이 프로세스로 전달되지 않도록 함.

- 하지만 우리가 터미널을 보고 있지 않을 때라도, 실행 되고 있던 프로세스의 로그를 모니터링할 방법이 필요하다.
- 일반적으로 `nohup` 명령어로 실행한 프로세스의 표준 출력은 `nohup.out` 파일에 기록된다.
- 다른 파일에 기록을 원할 경우, 다음 예제와 같이 Linux의 `Redirection` 을 활용할 수 있다.

```console
$ nohup java -Dserver.port=9090 -jar server.jar > server.log 2>&1 &
```

> **`2>&1`**
> 이는 다음을 표현한다.
> - `2` : 표준 오류(`stderr`).
> - `>` : 리디렉션 연산
> - `&1` : 표준 출력
> 즉, '표준 오류를 표준 출력과 동일한 경로로 전달하라'는 의미이다.

> **표준 오류(`stderr`)**
> *Stream of data that is generated by computer programs when they encounter an error or an exceptional condition.*

## IV. 디스크 용량 관리

#### 디스크 용량 상태 확인

##### 1. `df -h` : 파티션 별 용량 상태 확인
- `df` 는 `disk free` 의 줄임 표현이다.
- 파티션 별 크기 상태 확인 가능
- `-h` 또는 `--human-readable` 옵션을 통해 바이트가 아닌 KB, MB, GB 와 같은 단위로 표현된 크기 출력 가능

```console
$ df -h

Filesystem  Size  Used  Avail  Use%  Mounted on
drivers     460G  256G  204G    56%  /usr/lib/wsl/drivers
/dev/sdc    251G  3.6G  235G     2%  /
```

##### 2. `du -sh` : 파일 및 디렉토리 크기 확인
디스크 용량 확보를 위해 파티션 별 크기 상태를 확인했다면, 이제 파일 및 디렉토리 별 크기를 확인한다. 확인의 목적은 크게 두 가지이다.
- 전반적인 크기 확인 및 비정상적인 대상 식별
- 실제 삭제 대상 정의

이를 위해 가장 많이 사용하는 것이 `du -sh` 이다.
이때 `du` 는 `disk usage` 의 약자이다.

```console
$ du -sh ./*
36K  ./SimpleEchoServer
1.5M ./ddd-start2
32K  ./nbio-prac
120K ./todo_project.zip
```
명령어의 각 부분은 다음과 같은 의미를 표현하고 있다.

- `du` : 'disk usage' 명령ㅇ
- `-s` : 하위 디렉토리 용량 합 및 파일 크기 출력
- `-h` : Human-readable 한 단위로 크기 표현

파일을 제외한 '하위 디렉토리의 용량 합'만 알고싶다면 다음과 같이 사용한다. 상기한 예제와 명령어 및 옵션은 동일하나, 대상 표기에서 차이가 있다.
```console
$ du -sh */
```

##### 3. 디스크 용량 관리를 위한 방법 : 삭제, 이동, 압축
일반적으로 서버 프로그램 상에서 디스크 용량과 관련한 파일을 크게 두 가지로 생각해볼 수 있다.
- 1) 로그
- 2) 저장된 파일(임시 파일 등)

그리고 이 두 가지에 대해 세 가지 행동을 통해 디스크 용량 관리를 할 수 있다.
- 1) 삭제
- 2) 이동
- 3) 압축

로그를 남기는 것은 중요하나, 모든 데이터를 서버에 저장하는 것은 부담이 가는 일이다.

따라서 팀을 비롯한 유관한 조직 구성원과 논의하여, 이를 관리할 적절한 정책을 정하는 것이 필요하다.

서버에 직접 보관할 로그의 기간을 정의하는 것이 대표적이다.

- 1) 기간 정책을 정의한다. (ex. 30일)
- 2) 해당 기간을 넘긴 로그는 압축 또는 삭제하거나, 다른 저장소로 이동하여 보관한다.

예를 들어, 30일이 지난 로그 파일을 찾아 삭제하기 위해 `find` 명령어를 사용할 수 있다.
```console
$ find ./logs -mtime +29 -type f -delete
```

하지만 *널 카피(Null Copy)* 라는 방법을 이용해 삭제할 수 있다.

UNIX 계열 OS 에는 *Null Device* 혹은 *Null Device File* 이라는 개념이 있다.

해당 파일에 입력된 것은 모두 무시되도록 만들어둔 것이다.

이는 간단하게 output stream 을 삭제하기 위해 고안된 것이다.

<s>공허로 가는 입구로 생각을 하면 이해하기가 편했다!</s>

Linux OS 에서는 `/dev/null` 에 위치해있다.

```console
$ cp /dev/null out.log
```

위의 예제에서 사용된 `cp` 명령어는 복사를 수행한다.

`/dev/null` 에 위치한 'null device file` 을 `out.log` 파일로 복사하는 것이다.

*null device file* 은 'null' 이라는 개념을 파일처럼 취급하는 것으로 이해했다.

그렇기 때문에 해당 파일을 `out.log` 에 복사할 경우, `out.log` 의 내용이 모두 사라지게 되므로 해당 파일의 크기가 0이 되는 것이다.


로그를 보관할 때에도 디렉토리 크기가 지나치게 비대해지지 않도록 잘 나누어 저장해야 한다.

디렉토리가 지나치게 비대해질 경우, 탐색의 시간 복잡도가 커지기 때문이다.

이를 실천하는 일반적인 방법으로 '일자 혹은 시간 기준으로 폴더를 생성 후 로그 저장'하는 방법이다.

이외에도 로그 로테이션(Log Rotation) 방법을 활용하기도 한다.

> **로그 로테이션(Log Rotation)**
> 로그 파일의 개수를 정해두고(즉, 파일을 미리 생성해둔다.) 일정한 규칙에 따라 파일을 바꿔가며 로그를 기록하는 방식.


## V. 파일 디스크립터 제한
- 프로세스는 데이터 입출력이 필요할 때, OS로부터 *파일 디스크립터(File Descriptor)* 를 할당 받음.
- 이때, OS 수준 혹은 프로세스 수준, 서비스 수준에 따라 각각 파일 디스크립터 개수가 제한되어 있다.
- 모든 것을 파일의 개념으로 바라보는 UNIX 계열 시스템의 특징을 고려할 때, 할당 가능한 파일 디스크립터의 수는 곧 해당 사용자/프로세스/서비스가 동시에 열 수 있는 파일 또는 소켓의 수를 의미한다.
- 따라서 실제로 운영하는 서비스라면, 트래픽의 수준에 따라 이를 변경해주어야할 필요가 있으므로 모니터링하고 설정을 변경하는 법을 숙지해야한다.
- 만약 파일 디스크립터 제한에 도달하는 경우, `Too Many Open Files` 와 같은 오류를 만나게 된다!

### 1. 사용자 수준의 파일 디스크립터 제한 확인 및 변경
- `ulimit -a` 명령어를 이용하여 사용자의 파일 ㄹ디스크립터 개수 제한을 확인 가능`
```console
$ ulimit -a

real-time non-blocking time (microseconds, -R) unlimited
...
open files                                (-n) 1024
...
```
위의 출력문은 현재 터미널에 접속한 사용자가 생성한 프로세스의 파일 디스크립터 개수 제한이 1024개 라는 것을 보여준다.

변경은 크게 두 가지 관점에서 이루어진다.
- 1) 현 사용자 세션 내에서의 파일 디스크립터 제한 변경
- 2) 사용자의 기본(Default) 파일 디스크립터 제한 변경
 
> **1) 현 사용자 세션 내에서의 파일 디스크립터 제한 변경**
- `ulimit -n 개수` 명령어를 사용하여 변경

> **2) 사용자의 기본(Default) 파일 디스크립터 제한 변경**
- `/etc/security/limits.conf` 파일 내의 해당 항목 수치 변경을 통해 가능하다.
```console
* soft nofile 1000
* hard nofile 1000
```
예제는 다음과 같이 해석한다.
- `*` : 모든 사용자에 대해,
- `soft nofile 1000` : 기본적으로 1000개 제한,
- `hard nofile 1000` : 기본을 초과할 경우 최대 1000개 제한

### 2. 서비스 수준의 파일 디스크립터 제한 확인 및 변경

서비스는 크게 두 가지로 구분해 볼 수 있다.
- 1) `systemd`로 실행되는 서비스
- 2) 사용자에 의해 실행되는 서비스

> **1) `systemd`로 실행되는 서비스**

확인은 `systemctl show` 명령어를 이용하여 가능하다.
```console
$ systemctl show -p DefaultLimitNOFILE
DefaultLimitNOFILE=524888
```

이를 변경하고자 할 경우, `/etc/systemd/system.conf` 파일의 `DefaultLimitNOFILE` 값을 수정함으로써 이루어진다.

수정 후엔 `systemctl daemon-reload` 명령어를 통해 설정을 반영해야한다!

> **2) 사용자에 의해 실행되는 서비스**

큰 메커니즘은 `systemd`로 실행되는 서비스 경우와 다르지 않다.

어떤 서비스가 참조하는 설정 파일의 내용을 수정하는 것이다.

개별 서비스의 설정 파일은 통상 `/etc/systemd/system` 디렉토리 혹은 `/usr/lib/systemd/system` 디렉토리에 위치한다.

해당 설정 파일을 찾아 `LimitNOFILE` 설정을 추가한다.

```console
[Service]
LimitNOFILE=1048576
```

### 3. 프로세스 수준의 파일 디스크립터 제한 확인 및 변경
한 프로세스가 가질 수 있는 파일 디스크립터 수의 제한은 `sysctl fs.nr_open` 명령어를 사용하여 확인 가능하다.
```console
$ sysctl fs.nr_open
fs.nr_open = 107374186
```

기본적으로 충분히 크게 설정되어 있기 때문에 변경하는 경우가 많지 않지만 변경할 경우 `/eetc/sysctl.conf` 파일의 `fs.nr_open` 설정을 변경한다.

시스템 전체의 파일 디스크립터 개수 제한을 확인 및 변경 가능하다. `sysctl fs.file-max` 명령어를 통해 확인 가능하다.

변경 또한 마찬가지로 `sysctl.conf` 파일의 `fs.file-max` 설정을 변경함으로써 가능하다.

*`sysctl.conf` 수정 후엔 `sysctl -p` 명령어로 적용하는 것을 잊지 말자!*

PID를 이용하여 특정 프로세스의 파일 디스크립터 제한 값도 조회 가능하다.

```console
$ cat /proc/[Target PID]/limits
Limit            Soft Limit    Hard Limit    Units
...
Max open files   65535          65535        files
```

혹은 다음과 같이 `prlimit` 명령어를 통해서도 가능하다.
```console
$ prlimit --pid [target PID]
RESOURCE    DESCRIPTION                  SOFT      HARD
...
NOFILE      max number of open files     65535     65535
```

실제 프로세스가 사용 중인 파일 디스크립터 수를 확인할 경우 `lsof` 명령어를 사용한다.

'list of' 로 기억하니 쉽다.

```console
$ lsof -p 프로세스ID
$ lsof -p 프로세스ID | wc -l
```


