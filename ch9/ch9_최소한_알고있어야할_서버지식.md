# 9장. 최소한 알고있어야 할 서버 지식

> ***Introduction***
> - 규모가 큰 회사는 인프라 및 플랫폼 담당 팀과 서비스 개발팀이 분리되어 있음.
> > - 때문에 규모가 큰 회사에서 백엔드 개발 시작 시 OS 설치 및 설정, 관리 경험을 하지 못하기도 함.
> - 그러나, 서버 OS 에 대한 경험이 없다면, 문제 발생 시 해당 문제가 애플리케이션 레벨인지 OS 레벨인지 확인하기 어려울 수 있음.
> - 따라서, 기본적인 서버 관리는 할 수 있어야 한다.

> *서버 V.S 서버 프로그램*
> - *서버* 라는 용어는 맥락에 따라 다양한 대상을 의미함.
> > - ex. 물리 장비 혹은 가상화 장비, OS, 아파치 및 톰캣과 같은 웹 서버를 지칭할 때 모두 *서버* 라는 용어를 사용하기도 한다.
> - 본 챕터에서는 혼동을 피하기 위해 <u>서버 프로그램을 구동하는 OS를 *서버* </u>, 아파치 또는 톰캣 같은 프로그램은 *서버 프로그램* 으로 지칭하기로 정한다.
> - 또한, OS는 Linux 를 전제로 설명한다. 가장 많이 사용되는 OS 이기 때문.


## I. OS 계정과 권한

### 1. Linux OS 계정 종류
- 크게 다음의 두 가지 계정 종류가 존재한다.
  - *root*
  - *사용자(User)*
- Linux 에는 복수의 사용자를 묶어 지정하는 '그룹'의 개념도 존재한다.

> **root**
> - OS 설치 시 기본 생성되는 계정.
> - 모든 권한 보유한 *관리자 계정*
> - 통상 인프라 담당자만 해당 계정 접근 권한 보유 / 나머지 개발자는 별도로 생성한 사용자 계정 활용하여 서버 연결.
   

### 2. 파일/디렉토리에 대한 권한 확인 및 수정

#### 권한 확인
어떤 파일 혹은 디렉토리 실행 및 접근이 거부될 경우, 대상의 읽기/실행 권한을 확인해볼 필요가 있다.
리눅스에서는 `ls` 명령어를 활용하여 설정된 권한을 확인할 수 있다.
다음은 `ls -l` 명령어를 실행한 결과이다.

```console
-rw-r--r--. 1 vagrant vagrant 7 11월 10 08:24 README.md
-rwxr--r--. 1 vagrant vagrant 7 11월 10 08:26 run.sh
```
가장 앞의 9자리가 권한을 표현하는 정보이다.
다음과 같이 해석한다.
- 첫 세 자리 : 파일 및 디렉토리 소유자의 권한.
- 중간 세 자리 : 그룹의 권한.
- 마지막 세 자리 : 소유자 외 다른 계정의 권한

이에 따라 `README.sh` 접근 및 실행 권한을 해석해보면 다음과 같다.
- 소유자 : 읽기 및 쓰기 가능(`-rw`)
- 그룹 : 읽기만 가능(`r--`)
- 다른 계정 : 읽기만 가능(`r--`)

읽기(`w`)/쓰기(`r`)/실행(`x`) 는 다음과 같이 숫자와 대응하여 표현하기도 한다.
- `r` -> 4
- `w` -> 2
- `x` -> 1

#### 권한 수정
권한의 수정은 `chmod` 명령어를 활용한다. `chmod` 는 *Change Mode* 를 줄인 표현이다.
이를 활용하여 어떤 파일/디렉토리의 접근/실행 권한을 변경할 때에는 크게 두 가지 방법이 있다.
> 1) r, w, x 에 대응하는 숫자의 합을 활용하는 방법.
> 2) 대상과 권한, 그리고 명령어를 표현하는 영소문자를 활용하는 방법.
> 3) `sudo` 명령어를 활용하여 다른 사용자의 권한 획득하기.

> **1) r, w, x 에 대응하는 숫자의 합을 활용하는 방법**

예를 들어 `run.sh` 의 권한을 다음과 같이 변경하였다고 가정해보자.
```console
$ chmod 754 run.sh
```
`754` 는 각각 소유자, 그룹, 소유자 외 계정의 실행 및 접근 권한을 숫자 합으로 표현한 것이다.
즉, 다음과 동일하다.

```console
-rwxr-xr--. 1 vagrant vagrant 7 11월 10 08:26 run.sh
```
> **2) 대상과 권한, 그리고 명령어를 표현하는 영소문자를 활용하는 방법**
파일/디렉토리의 권한 설정 변경을 다음과 같은 관점에서 바라볼 수 있다.
1) 사용자 : '누구의 권한인가?' 를 의미한다. 소유자는 `u`, 그룹은 `g`, 다른 사용자는 `o`, 모든 사용자는 `a` 로 표현한다.
2) 동작 : 대상 사용자의 어떤 권한을 새로 부여할 것인지, 제거할 것인지와 같은 행위를 의미한다. 추가는 `+`, 제거는 `-`, 지정은 `=` 으로 표현한다.
3) 권한 : 어떤 권한을 추가 또는 제거할 것인지를 말한다. 각 권한은 앞서 기술한 바와 동일하다.

이를 활용하여 다음과 같이 `chmod` 명령어를 사용할 수 있다.
```console
$ chmod u+x run.sh
```
'소유자에게 run.sh 파일의 실행 권한을 부여하도록 설정한다.' 는 의미와 동일하다.

> **3) `sudo` 명령어를 활용하여 다른 사용자의 권한 획득하기

> **`sudo`**
- 현재 사용자로 실행 및 접근할 수 없는 파일/디렉토리에 접근하기 위해, 타당한 권한이 있는 사용자의 권한을 사용하여 실행하도록 하는 명령어

#### 왜 필요할까?
다음과 같은 상황을 생각해볼 수 있다.

- 서버의 root 권한을 일부 인프라 담당자만 갖는 경우가 많다.
- 개발자는 일반 계정을 부여받는다.
- 하지만 개발자도 root 권한이 필요한 상황이 왕왕 있다. (ex. `systemctl` 명령어로 아파치 서비스를 재시작해야 하는 경우 등)
- 그럴 때마다 인프라 담당자에게 전화를 해야 한다면 모두가 슬퍼진다.
- 그러나 root 계정을 냅다 넘겨주기엔 보안 관련하여 우려가 되는 지점이 있다.

이러한 상황을 타개하기 위해선 다음과 같은 것이 필요하다.
- 일반 사용자도 root 권한으로 접근/실행 가능한 파일 및 디렉토리에 접근해야 할 때가 있다.
- 하지만 root 계정 소유주의 입장에선, 모든 파일 및 디렉토리에 그런 방식으로 접근하도록 허용하기엔 무리가 있다.
- 따라서, root 계정 소유주가 '허용하는 범위'에 대해선 가능하도록 하는 방안이 있다.

위의 세 가지를 모두 제공하는 것이 바로 `sudo` 명령어 이다.

#### `sudo` 명령어를 사용하기 위한 설정 및 사용

- `sudo` 명령어의 제약조건을 정의하는 파일이 바로 `/etc/sudoers` 혹은 `/etc/sudoers.d/` 디렉토리에 위치한 파일.

해당 파일 내부에는 다음과 같은 사항이 기록되어 있다.
```console
root    ALL=(ALL) ALL
```

그리고 다음과 같이 해석할 수 있다.

- `root` : root 계정은,
- `ALL` : 모든 호스트에 대해
- `(ALL)` : 모든 사용자로 실행할 수 있다. ('as' 로 이해하면 알기 쉽다.)
- `ALL` : 모든 명령어를 실행할 수 있다.(허용 범위 정의)

하지만 '부여 받은 계정' 에 암호가 설정되어 있는 경우, 다음과 같은 설정으로 암호 입력을 우회할 수 있다.

```console
user1    ALL=(ALL) ALL NOPASSWD: ALL
```

위의 설정은 `user1`이 `sudo` 명령어를 사용할 경우, 어떤 파일/디렉토리에 접근 및 실행하더라도 암호를 요구하지 않도록 하는 것이다.
하지만 이는 다시 보안 취약점을 드러낼 가능성이 있다.

따라서 명확하게 필요한 부분을 정의하여, 해당 부분에 대해서만 `sudo` 명령어 사용이 가능하도록 하는 것이 좋다.

```console
user1    ALL=(ALL) NOPASSWD: /usr/bin/systemctl start docker
```

## II. 프로세스 확인하기








